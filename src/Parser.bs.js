// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Typescript = require("typescript");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");

var ScriptTarget = {};

var SyntaxKind = {};

var Internal = {
  ScriptTarget: ScriptTarget,
  SyntaxKind: SyntaxKind
};

function parseDiagnostic(json) {
  return {
          start: Json_decode.field("start", Json_decode.$$int, json),
          messageText: Json_decode.field("messageText", Json_decode.string, json),
          category: Json_decode.field("category", Json_decode.$$int, json),
          length: Json_decode.field("length", Json_decode.$$int, json),
          code: Json_decode.field("code", Json_decode.$$int, json)
        };
}

var decoders = {};

function node(json) {
  var syntaxKind = Json_decode.field("kind", Json_decode.$$int, json);
  var decoder;
  try {
    decoder = List.assoc(syntaxKind, decoders);
  }
  catch (exn){
    decoder = unknown;
  }
  console.log(decoder);
  return Curry._1(decoder, json);
}

function declareKeyword(json) {
  return {
          TAG: /* DeclareKeyword */0,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json)
          }
        };
}

function exportKeyword(json) {
  return {
          TAG: /* ExportKeyword */1,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json)
          }
        };
}

function numberKeyword(json) {
  return {
          TAG: /* NumberKeyword */3,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json)
          }
        };
}

function stringKeyword(json) {
  return {
          TAG: /* StringKeyword */2,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json)
          }
        };
}

function identifier(json) {
  return {
          TAG: /* Identifier */4,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            escapedText: Json_decode.field("escapedText", Json_decode.string, json),
            text: Json_decode.field("text", Json_decode.string, json)
          }
        };
}

function functionDeclaration(json) {
  return {
          TAG: /* FunctionDeclaration */5,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            modifiers: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("modifiers", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            name: Json_decode.field("name", node, json),
            typeParameters: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("typeParameters", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            parameters: Json_decode.field("parameters", (function (param) {
                    return Json_decode.array(node, param);
                  }), json),
            type_: Json_decode.field("type", node, json)
          }
        };
}

function interfaceDeclaration(json) {
  return {
          TAG: /* InterfaceDeclaration */6,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            modifiers: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("modifiers", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            name: Json_decode.field("name", node, json),
            typeParameters: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("typeParameters", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            members: Json_decode.field("members", (function (param) {
                    return Json_decode.array(node, param);
                  }), json)
          }
        };
}

function propertySignature(json) {
  return {
          TAG: /* PropertySignature */7,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            modifiers: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("modifiers", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            name: Json_decode.field("name", node, json),
            questionToken: Json_decode.optional((function (param) {
                    return Json_decode.field("questionToken", node, param);
                  }), json),
            type_: Json_decode.field("type", node, json)
          }
        };
}

function questionToken(json) {
  return {
          TAG: /* QuestionToken */8,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json)
          }
        };
}

function typeAliasDeclaration(json) {
  return {
          TAG: /* TypeAliasDeclaration */9,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            name: Json_decode.field("name", node, json),
            typeParameters: Json_decode.withDefault([], (function (param) {
                    return Json_decode.field("typeParameters", (function (param) {
                                  return Json_decode.array(node, param);
                                }), param);
                  }), json),
            type_: Json_decode.field("type", node, json)
          }
        };
}

function typeLiteral(json) {
  return {
          TAG: /* TypeLiteral */10,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            members: Json_decode.field("members", (function (param) {
                    return Json_decode.array(node, param);
                  }), json)
          }
        };
}

function sourceFile(json) {
  return {
          TAG: /* SourceFile */11,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            text: Json_decode.field("text", Json_decode.string, json),
            languageVersion: Json_decode.field("languageVersion", Json_decode.$$int, json),
            fileName: Json_decode.field("fileName", Json_decode.string, json),
            languageVariant: Json_decode.field("languageVariant", Json_decode.$$int, json),
            isDeclarationFile: Json_decode.field("isDeclarationFile", Json_decode.bool, json),
            statements: Json_decode.field("statements", (function (param) {
                    return Json_decode.array(node, param);
                  }), json),
            nodeCount: Json_decode.field("nodeCount", Json_decode.$$int, json),
            identifierCount: Json_decode.field("identifierCount", Json_decode.$$int, json),
            parseDiagnostics: Json_decode.field("parseDiagnostics", (function (param) {
                    return Json_decode.array(parseDiagnostic, param);
                  }), json)
          }
        };
}

function parameter(json) {
  return {
          TAG: /* Parameter */12,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            dotDotDotToken: Json_decode.optional((function (param) {
                    return Json_decode.field("dotDotDotToken", node, param);
                  }), json),
            name: Json_decode.field("name", node, json),
            questionToken: Json_decode.optional((function (param) {
                    return Json_decode.field("questionToken", node, param);
                  }), json),
            type_: Json_decode.field("type", node, json)
          }
        };
}

function typeParameter(json) {
  return {
          TAG: /* TypeParameter */13,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            name: Json_decode.field("name", node, json)
          }
        };
}

function typeReference(json) {
  return {
          TAG: /* TypeReference */14,
          _0: {
            pos: Json_decode.field("pos", Json_decode.$$int, json),
            end_: Json_decode.field("end", Json_decode.$$int, json),
            typeName: Json_decode.field("typeName", node, json)
          }
        };
}

function unknown(json) {
  var kind = Json_decode.field("kind", Json_decode.$$int, json);
  return {
          TAG: /* Unknown */15,
          _0: kind
        };
}

Caml_obj.update_dummy(decoders, {
      hd: [
        Typescript.SyntaxKind.DeclareKeyword,
        declareKeyword
      ],
      tl: {
        hd: [
          Typescript.SyntaxKind.ExportKeyword,
          exportKeyword
        ],
        tl: {
          hd: [
            Typescript.SyntaxKind.NumberKeyword,
            numberKeyword
          ],
          tl: {
            hd: [
              Typescript.SyntaxKind.StringKeyword,
              stringKeyword
            ],
            tl: {
              hd: [
                Typescript.SyntaxKind.Identifier,
                identifier
              ],
              tl: {
                hd: [
                  Typescript.SyntaxKind.FunctionDeclaration,
                  functionDeclaration
                ],
                tl: {
                  hd: [
                    Typescript.SyntaxKind.InterfaceDeclaration,
                    interfaceDeclaration
                  ],
                  tl: {
                    hd: [
                      Typescript.SyntaxKind.TypeAliasDeclaration,
                      typeAliasDeclaration
                    ],
                    tl: {
                      hd: [
                        Typescript.SyntaxKind.TypeLiteral,
                        typeLiteral
                      ],
                      tl: {
                        hd: [
                          Typescript.SyntaxKind.PropertySignature,
                          propertySignature
                        ],
                        tl: {
                          hd: [
                            Typescript.SyntaxKind.QuestionToken,
                            questionToken
                          ],
                          tl: {
                            hd: [
                              Typescript.SyntaxKind.SourceFile,
                              sourceFile
                            ],
                            tl: {
                              hd: [
                                Typescript.SyntaxKind.Parameter,
                                parameter
                              ],
                              tl: {
                                hd: [
                                  Typescript.SyntaxKind.TypeParameter,
                                  typeParameter
                                ],
                                tl: {
                                  hd: [
                                    Typescript.SyntaxKind.TypeReference,
                                    typeReference
                                  ],
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

var decode = node;

var Decoder = {
  parseDiagnostic: parseDiagnostic,
  decoders: decoders,
  node: node,
  declareKeyword: declareKeyword,
  exportKeyword: exportKeyword,
  numberKeyword: numberKeyword,
  stringKeyword: stringKeyword,
  identifier: identifier,
  functionDeclaration: functionDeclaration,
  interfaceDeclaration: interfaceDeclaration,
  propertySignature: propertySignature,
  questionToken: questionToken,
  typeAliasDeclaration: typeAliasDeclaration,
  typeLiteral: typeLiteral,
  sourceFile: sourceFile,
  parameter: parameter,
  typeParameter: typeParameter,
  typeReference: typeReference,
  unknown: unknown,
  decode: decode
};

console.log(List.map((function (k) {
            console.log(k);
            
          }), decoders));

function parse(fileName, source) {
  return node(Typescript.createSourceFile(fileName, source, Typescript.ScriptTarget.ES2015, false));
}

exports.Internal = Internal;
exports.Decoder = Decoder;
exports.parse = parse;
/* decoders Not a pure module */
